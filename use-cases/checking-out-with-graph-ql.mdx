## Checking out with GraphQL

A large part of working in the retail domain is buying something. Once you have selected the thing you want, you will need to pay for it. The complexity of this tends to land outside of the schema. The schmea we have for a viewers cart and payments right now looks something like the following:

```graphql
type Query {
  viewer: User
}

type User @key(fields: "id") {
  id: ID!

  """
  Saved payment methods that can be used to submit orders
  """
  paymentMethods: [PaymentMethod]

  """
  The user's active cart session. Once the cart items have been purchases, they transition to an Order
  """
  cart: Cart
}

"""
An user's saved cart session. Only one cart can be active at a time
"""
type Cart {
  """
  Items saved in the cart session
  """
  items: [Variant]

  """
  The current total of all the items in the cart, before taxes and shipping
  """
  subtotal: Float
}

"""
A saved payment option for an user
"""
type PaymentMethod {
  id: ID!
  name: String
  description: String
  type: PaymentType!
}

"""
A fix set of payment types that we accept
"""
enum PaymentType {
  CREDIT_CARD
  DEBIT_CARD
  BANK_ACCOUNT
}
```

This is a great start and with the flowing few enhancements we can stat describing a basic checkout workflow.

schema additions:

```graphql
type Mutation {
  viewer: ViewerMutaitons
}

type ViewerMutaitons {
  checkout(paymentMethodId: String!): CheckoutResult
  addVariantToCart(variantId: string, quantity: Int): Boolean
  removeVariantToCart(variantId: string, quantity: Int): Boolean
}

type ResultWithMessage {
  successful: Boolean
  message: String
}

type CheckoutResult {
  successful: Boolean
  orderID: ID
}
```

This all hinges on our cart being set up. Lucky for us the cart is already set up for a few users. If you look at the schema, the user id is not supplied as a query variable, that is by design. The user is pulled from a header. In the real world this would come from your auth provider and be pulled out of a jwt or something similar. In our case, for this demo, the user id is pulled from the header `user-id`. Using the following queries we should be able to fetch what is currently in our cart:

query:

```graphql
query GetCart {
  viewer {
    id
    username
    cart {
      items {
        product {
          title
          description
        }
        inventory {
          inStock
        }
        size
      }
      subtotal
    }
  }
}
```

headers:

```JSON
{
  "x-user-id":"user:2"
}
```

results:

```JSON
{
  "data": {
    "viewer": {
      "id": "user:2",
      "username": "User Two",
      "cart": {
        "items": [
          {
            "price": 600.25,
            "product": {
              "title": "Air Jordan 1 Mid",
              "description": "Air Jordan 1 Mid is a blue, grey and white sneaker from the iconic jordan brand"
            },
            "inventory": {
              "inStock": false
            },
            "size": "10"
          }
        ],
        "subtotal": 600.25
      }
    }
  }
}
```

This query grabs all of the nessacary data to display the page before hitting the checkout button. Once the checkout button is hit we will go to a page where we can select our payment method. The flowwing query shows the payment methods for user 2.

query:

```graphql
query GetViewersPaymentMethods {
  viewer {
    paymentMethods {
      name
      description
      type
      id
    }
  }
}
```

headers:

```JSON
{
  "x-user-id":"user:2"
}
```

results:

```JSON
{
  "data": {
    "viewer": {
      "paymentMethods": [
        {
          "name": "User Two's first debit car",
          "description": null,
          "type": "DEBIT_CARD",
          "id": "paymentMethod:3"
        }
      ]
    }
  }
}
```

With this data we should be able to present the user with all of their payment methods, or prompt them to add one. Once a selection is made, we can execute the next mutation to comeplete the checkout and create an order.

mutation:

```graphql
mutation checkout($paymentMethodId: String!) {
  viewer {
    checkout(paymentMethodId:$paymentMethodId) {
      successful
      orderID
  }
}
```

headers:

```JSON
{
  "x-user-id":"user:2"
}
```

variables:

```JSON
{
  "paymentMethodId":"paymentMethod:3"
}
```

results:

```JSON
{
  "data": {
    "viewer": {
      "checkout": [
        {
          "successful": true,
          "orderID": "order:7"
        }
      ]
    }
  }
}
```

**note that this will not work in explorer due to the schema not being there**

This small return gives us enought information to tell the viewer that their checkout request was successful and send them to a order page or give them an "ops something went wrong" error message.
