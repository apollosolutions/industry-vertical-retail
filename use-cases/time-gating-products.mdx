# Time Gating Products

There are two different places to put in a gate for displaying products that are released at that time.

- The Backend service
- The graphql

These two places have a similar way to get the way to get the information in is roughly the same. There can be an implicit or explicit way to handle this though the graph.

If you are heading down the implicit way of doing filtering out products then there are no schema additions needed past a `releaseDate` or something similar. This will be checked against in all the resolvers that would return a product and see if the release date is in the past. This could live in either the resolver or in the backend service behind the graph.

We will need to a schema addition or two if we want to allow for a release date to be passed in. This would include adding a input parameter `releaseDate` to each place to resolve to a product or a list of products. This would then be used in the same way as the implicit way described above. This could also be accomplished by a header too. The benefits of a header is that its passed in once and propagated easily though the graph to where it needs to be used.

### Impacts of Gating Products

With adding the functionality to have gated releases of products there are a few things that we need to keep in mind. Mainly the potential increase in errors, the implications on linking and the implementations on lists.

- The update to remove products that are not released yet could cause a potential null value. This would cause problems and errors when coupled with non-null fields. So keep in mind that this filtering could lead to an increase in errors, don't be alarmed.
- When linking entities from multiple subgraphs, we could run into a some problems. The two buckets of problems we have are extending an entity that is expired but still returning data and leaking IDs that should not be removed. Both of these problems can be resolved by checking to see if a product is released before returning the ID. If an ID was returned then partial data could be returned when it should not be. This is also how IDs can leak, if one subgraph returns an ID and another returns null, the ID will still be returned.
- The other note to take into account is the effect on lists. The same thing that applies above about linking entities together applies here. The one addition is some graphs draw a line between an empty list and null. This could cause problems when it comes to empty lists, by removing a non released item from the list potentially making it an empty list.
